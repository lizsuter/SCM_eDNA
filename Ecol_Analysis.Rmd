---
title: "Processing Results from DADA2 to make plots, do some statistics"
author: "Liz Suter"
date: "`r Sys.Date()`"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

[Link](https://htmlpreview.github.io/?https://github.com/lizsuter/SCM_eDNA/blob/main/Ecol_Analysis.nb.html) to notebook  

[Link](https://github.com/lizsuter/SCM_eDNA) to github repo.
<br>


## Load packages

```{r}
library(tidyverse)
library(readxl)
library(phyloseq)
#library(dada2)
library(Biostrings)
#library(DECIPHER)
library(phangorn)
library(readr)
library(seqinr)
library(decontam)
library(ape)
library(vegan)
#library(philr)
library(RColorBrewer)
library(microbiome)
#library(DESeq2)
library(compositions);
library(cowplot)
library(plotly)
library(htmlwidgets)
library(withr)
library(lubridate)
```

##  Import and prepare the data from eDNA 

#### Import Metadata
```{r}
metadata <- read_csv("sample_data.csv")
```


#### Import DADA2 results:
Import count table and taxonomy file. I slightly modified otutable.csv in Excel to otutable_mod.csv to remove the quotes around seq names and put NA placehoder as first col name (which was above row names)
```{r}
# Import Count table. Skip first row of tsv file, which is just some text
count_table <- read_table2("results/otutable_mod.csv")
colnames(count_table)[1] <- "SampleID"

# Import taxonomy of ASVs
taxonomy <- read_csv(file="results/tax_sequences_blast_taxonomy.csv")
# remove first col of sequential numbers
taxonomy[,1] <- NULL
# filter out sequences with low PID (recommended by Sara)
taxonomy <- filter(taxonomy, PID > 92)

# remove BLAST metadata and just retain taxonomy (necessary for further processing below)
drop.cols <- c(colnames(taxonomy)[2:9],'RefSeq_Tax_ID_1')
taxonomy <-  select(taxonomy, -one_of(drop.cols))


# And import the Common names, as curated by Sara. Join to taxonomy
commonnames <- read_excel("Trawls MASTER 2020 _mod_ES.xlsx",7)
commonnames

taxonomy <- left_join(taxonomy, commonnames, by = "ASV_ID")
taxonomy

```
Filtering removed seqs 110, 332 (Gobiosoma ginsburgi and Belone belone)
*Note for Sara* should we consider setting this at 97% which is more robust and still leaves 334 unique ASVs (rather than 379 with the 92% cutoff in the settings above)

Preview datasets
```{r}
count_table
taxonomy
metadata
```




#### Make phyloseq object

I want to use the phyloseq package for some plotting/ statistics, which first requires making phyloseq objects out of each of input data tables- 

```{r}
count_table_matrix <- as.matrix(count_table[,2:392]) # convert count table to matrix, leaving out character column of sample ID
rownames(count_table_matrix) <- count_table$SampleID # add back in Sample IDs as row names
ASV	=	otu_table(count_table_matrix, taxa_are_rows =  FALSE)

taxonomy_matrix <- as.matrix(taxonomy[,2:9])
rownames(taxonomy_matrix) <- taxonomy$ASV_ID 
TAX	=	tax_table(taxonomy_matrix)

META	=	sample_data(data.frame(metadata, row.names = metadata$`SampleID`))
```


First check that the inputs are in compatible formats by checking for ASV names with the phyloseq function, taxa_names
```{r}
head(taxa_names(TAX))
head(taxa_names(ASV))
```

And check sample names were also detected
```{r}
# Modify taxa names in ASV, which are formatted with the sample ID, underscor, fastq ID. Don't need this fastq ID anymore and want it to match the sample names from metadata
sample_names(ASV) <-  sample_names(ASV) %>%
  str_replace_all(pattern = "_S[:digit:]+",replacement = "")


head(sample_names(ASV))
head(sample_names(META))
```

And make the phyloseq object
```{r}
ps <- phyloseq(ASV,	TAX,	META)
```



## Quality check and filtering- eDNA

### Rarefaction curves

```{r}
rarecurve(otu_table(ps), step=50, cex=0.5)

# save as .eps
setEPS()
postscript("Figures/rarefaction.eps")
rarecurve(otu_table(ps), step=50, cex=0.5)
dev.off()
```
Most samples look like they were sampled to completion. Be weary of T3S11, T1S2, and maybe T4S5


### Filtering

Check some features of the phyloseq object
```{r}
rank_names(ps)

unique(tax_table(ps)[, "superkingdom"])
unique(tax_table(ps)[, "phylum"])
unique(tax_table(ps)[, "class"])
```

There are some ASVs with `NA` as superkingdom, phylum, or class annotation- delete these. 

```{r}
ps <- subset_taxa(ps, !is.na(superkingdom) & !is.na(phylum) & !is.na(class))

unique(tax_table(ps)[, "superkingdom"])
unique(tax_table(ps)[, "phylum"])
unique(tax_table(ps)[, "class"])
nrow(tax_table(ps)) # number of ASVs left
```
378 ASVs still remain...


Also check class Mammalia, to see if contamination or real:
```{r}
tax_table(subset_taxa(ps, class == 'Mammalia'))
```
These are human, wild boar, cat (...cat lady), and cattle. All are contamination so delete all Mammalia

```{r}
ps <- subset_taxa(ps, !class == 'Mammalia')
unique(tax_table(ps)[, "class"])
```

Next check the "Insecta" entries
```{r}
tax_table(subset_taxa(ps, class == 'Insecta'))
```

The onlly Insecta is Linepithema humile, which are ants so delete these too..
```{r}
ps <- subset_taxa(ps, !class == 'Insecta')
unique(tax_table(ps)[, "class"])
```


### Plot total sequences by phyla to check out sequencing effort

Check overall how the phyla are distributed among samples

```{r}
# First aglomerate the ASVs at the phylum level using the phyloseq function, tax_glom
superkingdomGlommed = tax_glom(ps, "superkingdom")

# and plot
plot_bar(superkingdomGlommed, x = "Sample")

ggsave(filename = "Figures/seqdepth.eps", plot = plot_bar(superkingdomGlommed, x = "Sample"), units = c("in"), width = 9, height = 6, dpi = 300, )# and save

```
Total sequences reveals certain samples had very low sequencing effort: T1S7, T1S8, T3S11, and, not as bad, T1S2 and T4S5



The rarefaction analysis also showed T1S2 and T4S5 samples were likely not sequenced to completion. Therefore remove these 5 samples from analysis
```{r}
ps <- subset_samples(ps, !SampleID == "T1S7" & !SampleID == "T1S8" & !SampleID == "T3S11" & !SampleID == "T1S2" & !SampleID == "T4S5")

ps
```

50 samples remaining with 368 ASVs


Remove Pos Controls (all hits in positive controls are the same family- I assume this is expected)
```{r}
ps <- subset_samples(ps, !SampleID == "T1PosCon" & !SampleID == "T2PosCon" & !SampleID == "T3PosCon")
ps
```


And lastly, correct some taxonomy: According to Sara, Engraulis encrasicolus (European anchovy) should be Anchoa mitchilli (Bay anchovy):

```{r}
tax_table(ps) <- gsub(tax_table(ps), pattern = "Engraulis encrasicolus", replacement = "Anchoa mitchilli")  

```

47 samples remainwith 368 unique ASVs




## Abundance plots- eDNA

For plotting, use *relative abundances* (# of ASV sequences/sum total sequences in sample), calculated easily using microbiome::transform

```{r}
ps_ra <- microbiome::transform(ps, transform = "compositional")
```

Export the relative abundance matrix so Sara can have it:
```{r}
# Extract abundance matrix from the phyloseq object
RelAbun_matrix = as(otu_table(ps_ra), "matrix")

# Coerce to data.frame
RelAbun_dataframe = as.data.frame(RelAbun_matrix)

# Export
write.csv(RelAbun_dataframe,"results/otutable_relabun.csv", row.names = TRUE)

```



### Plot abundance of families from all samples to do some quality control
Then aglomerate the ASVs at the family level using the phyloseq function, tax_glom
```{r}
familyGlommed_RA = tax_glom(ps_ra, "family")
family_barplot <- plot_bar(familyGlommed_RA, x = "Sample", fill = "family")
family_barplot

```
**NOTES** for Sara

- There are some samples, (T1S3, T1S6, T2S11, T3S10, T3S4, T3S5, T3S9, T4S4, T4S7, T5S7) which are composed almost exclusively of 1 family. This might be fine, but I'm not used to seeing this with prokaroytic data. Just want to check with you



Agglomerate by species to see if I get the same 38 unique species Sara sees:

```{r}
speciesGlommed_RA = tax_glom(ps_ra, "CommonName")
speciesGlommed_RA
tax_table(speciesGlommed_RA)

```

**NOTES** for Sara

- I am getting 43 unique species- which ones am I missing that should be removed?
- Also there are two species you are calling Bay anchovy- Engraulis mordax and Anchoa mitchilli. Should the Engraulis mordax be changed to Anchoa mitchilli, similar to Engraulis encrasicolus ?


### Bubble plots

Based on my previous [scripts](https://github.com/lizsuter/Cariaco_Euk) with Cariaco Eukaryotic data
```{r}
# convert ps object to dataframe using phyloseq's psmelt
species_df <- psmelt(speciesGlommed_RA)

# replace zeroes in the table with NA
species_df[species_df == 0] <- NA

# and remove rows with NAs in abundance  (this is so they don't appear as small dots in plot)
species_df <-  filter(species_df, !is.na(Abundance))
```



Plot by species, scientific name
```{r}
speciesbubbleplot_eDNA_sciname <- ggplot(species_df, aes(x = Station, y = fct_rev(species), color = Station)) + # the fancy stuff around y (species) helps to present it in reverse order in the plot (from top to btm alphabetically)
  geom_point(aes(size = Abundance, fill = Station), color = "black", pch = 21)+
  scale_size(range = c(1,15)) +
  scale_size_area(breaks = c(0,.25,.5,.75,1), max_size = 6)+
  xlab("")+
  ylab("")+
  labs(size="Relative Abundance")+
  theme_bw() +
  scale_fill_brewer(palette="Paired") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  facet_grid(Datecode~Bayside, scales = "free", space = "free", drop= TRUE)

speciesbubbleplot_eDNA_sciname
```



Plot by species common name

```{r}
speciesbubbleplot_eDNA_comname <- ggplot(species_df, aes(x = Station, y = fct_rev(CommonName), color = Station)) + # the fancy stuff around y (CommonName) helps to present it in reverse order in the plot (from top to btm alphabetically)
  geom_point(aes(size = Abundance, fill = Station), color = "black", pch = 21)+
  scale_size(range = c(1,15)) +
  scale_size_area(breaks = c(0,.25,.5,.75,1), max_size = 6)+
  xlab("")+
  ylab("")+
  labs(size="Relative Abundance")+
  theme_bw() +
  scale_fill_brewer(palette="Paired") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  facet_grid(Datecode~Bayside, scales = "free", space = "free", drop= TRUE)

speciesbubbleplot_eDNA_comname
```


Exportfigures
```{r}
ggsave(filename = "Figures/speciesbubbleplot_eDNA_sciname.eps", plot = speciesbubbleplot_eDNA_sciname, units = c("in"), width = 7, height = 12, dpi = 300)

ggsave(filename = "Figures/speciesbubbleplot_eDNA_comname.eps", plot = speciesbubbleplot_eDNA_comname, units = c("in"), width = 7, height = 12, dpi = 300)
```

**NOTE** on above. The common name plot has two entries in the Bay anchovy row because, as mentioned above, there are two different species name that are labelled as Bay Anchovy. Is it OK to group these as same species (Anchoa mitchilli)



##  Import and prepare the data from trawls 

### Import Trawl Master sheet

```{r}
# import 4th sheet from  Excel file which contains morphometric data for each individual collected for every date
trawl_master <- read_excel("Trawls MASTER 2020 _mod_ES.xlsx",4)
trawl_master

# and import 6th sheet which is station info
stations <- read_excel("Trawls MASTER 2020 _mod_ES.xlsx",6)
stations

```

### Convert to count table
Make an equivalent to an OTU table, grouping by date and location and representing counts for every unique species

```{r}
trawl_counts <- trawl_master %>%
  group_by(DATECODE, STATION_NO, CommonName) %>%
  tally(name = "count")

trawl_counts
```

and link station names instead of numbers to count table
```{r}
trawl_counts <- left_join(trawl_counts, stations, by = "STATION_NO")
trawl_counts
```

Remove 09/16/20 since there is no equivalent eDNA from that date
```{r}
trawl_counts <- trawl_counts %>%
  filter(DATECODE != "20200916")

trawl_counts
```


## Abundance plots- Trawls

```{r}
speciesbubbleplot_trawl_comname <- ggplot(trawl_counts, aes(x = STATION_NA, y = fct_rev(CommonName), color = STATION_NA)) + 
  geom_point(aes(size = log10(count), fill = STATION_NA), color = "black", pch = 21)+
  scale_size(range = c(1,15)) +
  scale_size_area(breaks = c(.01,.1, .3, .5, 1, 3), max_size = 6)+
  xlab("")+
  ylab("")+
  labs(size="Log(counts)", fill = "Station")+
  theme_bw() +
  scale_fill_brewer(palette="Paired") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  facet_grid(DATECODE~BAYSIDE, scales = "free", space = "free", drop= TRUE)

speciesbubbleplot_trawl_comname
```


Export figure
```{r}
ggsave(filename = "Figures/speciesbubbleplot_trawl_comname.eps", plot = speciesbubbleplot_trawl_comname, units = c("in"), width = 6.75, height = 13, dpi = 300)
```


## Compare Trawl and eDNA

Count unique species across all stations, grouped by date, for each method (trawl, eDNA)
```{r}
trawl_uniques <- trawl_counts %>%
  group_by(DATECODE, CommonName) %>%
  summarise(Trawl_Count = sum(count, na.rm=TRUE))

trawl_uniques

eDNA_uniques <- species_df%>%
  group_by(Datecode, CommonName) %>%
  summarise(eDNA_RelAbun = sum(Abundance, na.rm=TRUE))

eDNA_uniques

# Combine into one dataframe
trawl_eDNA_abun_table <- full_join(trawl_uniques, eDNA_uniques, by=c("CommonName" = "CommonName", "DATECODE" = "Datecode"))

trawl_eDNA_abun_table
```


Count total number of species from each method for each date
```{r}
eDNA_richness <- tally(eDNA_uniques, name = "eDNA")
trawl_richness <- tally(trawl_uniques, name = "trawl")

speciesrichness <- full_join(eDNA_richness, trawl_richness, c("Datecode" = "DATECODE"))
speciesrichness <- pivot_longer(speciesrichness, !Datecode, names_to = "Method", values_to = "Richness")

speciesrichness$Datecode <- ymd(speciesrichness$Datecode) # convert to date format (better for plotting)

speciesrichness
```


Plot side-by-side
```{r}
species_richness_plot <- ggplot(speciesrichness, aes(x =Datecode, y = Richness)) +
  geom_line(aes(color = Method), size = 3) +
  theme_bw() +
  xlab("") +
  ylab("Species Richness")

species_richness_plot

# export plot
ggsave(filename = "Figures/species_richness_plot.eps", plot = species_richness_plot, units = c("in"), width = 4, height = 3, dpi = 300)
```


Sum total number of species across all dates/ stations for entire study
```{r}
species_sums_abun_table <- trawl_eDNA_abun_table %>%
  group_by(CommonName) %>%
  summarise(Trawl = sum(Trawl_Count, na.rm=TRUE), eDNA = (sum(eDNA_RelAbun, na.rm=TRUE))) %>%
  pivot_longer(!CommonName, names_to = "Method", values_to = "Abundance")
  
# turn zeroes to NA so they don't plot 
species_sums_abun_table <- na_if(species_sums_abun_table,0)

species_sums_abun_table
```



For each species, plot side-by-side comparison of abundance (summed over whole study) using each method

```{r}
# First create a custom color scale to make this pretty
myColors <- colorRampPalette(brewer.pal(11,"Spectral"))(55)
names(myColors) <- levels(unique(species_sums_abun_table$CommonName))
colScale <- scale_colour_manual(name = "CommonName",values = myColors)

species_abun_sum_plot <- ggplot(species_sums_abun_table, aes(x = Abundance, y = reorder(CommonName, Abundance, function(x){sum(x,na.rm = TRUE)}), color = CommonName)) +
  geom_point(size = 5) +
  facet_wrap(~fct_rev(Method), scales = "free") +
  theme_bw() +
  xlab("Abundance") +
  ylab("") + 
  colScale +
  theme(legend.position = "none")

species_abun_sum_plot
```

Export plot
```{r}
ggsave(filename = "Figures/species_abun_sum_plot.eps", plot = species_abun_sum_plot, units = c("in"), width = 7, height = 8, dpi = 300)
```




## Ordinations

### PCA
PCA is essentially a type of PCoA  using the Euclidean distance matrix as input. When combined with a log-ratio transformation of the count table, this is deemed appropriate for *compositional* datasets. It is also [recommended](https://sites.google.com/site/mb3gustame/indirect-gradient-analysis/pca) as a first step in exploratory analyses of sequencinging datasets.

First do a **CLR, centered log ratio** transformation of the absolute abundance data (after filtering), as suggested by [Gloor et al. 2017](https://www.frontiersin.org/articles/10.3389/fmicb.2017.02224/full)  
```{r}
# Estimate covariance matrix for CLR-transformed ASV table
clr_asv_table_ps <- data.frame(compositions::clr(otu_table(ps)))
```


Generate the PCA and visualize axes
```{r}
# Generate a Principle Component Analysis (PCA) and evaluated based on the eigen decomposition from sample covariance matrix. 
lograt_pca <- prcomp(clr_asv_table_ps) 
# NOTE- this is equivalent to first making a Euclidean distance matrix using the CLR data table and then running a PCoA. A Euclidean distance matrix of a log-transformed data table = an Aitchison distance matrix. So this is equivalent to the compositional methods listed in Gloor et al.

# Visual representation with a screeplot
lograt_variances <- as.data.frame(lograt_pca$sdev^2/sum(lograt_pca$sdev^2)) %>% #Extract axes
  # Format to plot
  select(PercVar = 'lograt_pca$sdev^2/sum(lograt_pca$sdev^2)') %>% 
  rownames_to_column(var = "PCaxis") %>% 
  data.frame
head(lograt_variances)

# Plot screeplot
ggplot(lograt_variances, aes(x = as.numeric(PCaxis), y = PercVar)) + 
  geom_bar(stat = "identity", fill = "grey", color = "black") +
  theme_minimal() +
  theme(axis.title = element_text(color = "black", face = "bold", size = 10),
        axis.text.y = element_text(color = "black", face = "bold"),
        axis.text.x = element_blank()) +
  labs(x = "PC axis", y = "% Variance", title = "Log-Ratio PCA Screeplot, CLR Tranformation")
```

Plot in 3D using first 3 axes since the 2nd and 3rd are similar proportions of variance. Total variance explained by first three: 15.7 + 10.5 + 10.0 = 36.2%)

Visualize the PCA- 

```{r}
# Extract variances from the clr pca
pca_lograt_frame <- data.frame(lograt_pca$x) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
pca_lograt_frame <- left_join(pca_lograt_frame, metadata, by = "SampleID")
head(pca_lograt_frame)

# Select eigenvalues from dataframe, round to 4 places and multiply by 100 for plotting. These will be the axes for the 3-D plot
eigenvalues<-round(lograt_variances[,2], digits = 4)*100

# Plotly - 3-D
pca_lograt <- plot_ly(pca_lograt_frame, type='scatter3d', mode='markers',
        x=~PC1,y=~PC2,z=~PC3,colors=~brewer.pal(11,'Paired'),
        color=~Station, symbols = c('circle','diamond'), symbol=~Bayside)%>%
  layout(font=list(size=12),
         title='CLR-Euclidean PCA',
         scene=list(xaxis=list(title=paste0('Co 2 ',eigenvalues[2],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    yaxis=list(title=paste0('Co 3 ',eigenvalues[3],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    zaxis=list(title=paste0('Co 1 ',eigenvalues[1],'%'),
                               showticklabels=FALSE,zerolinecolor='black')))
pca_lograt

# save in "Embedded_figures" dirctory so that it can be hosted at Github and embedded in this notebook
withr::with_dir('Embedded_figures', htmlwidgets::saveWidget(as_widget(pca_lograt), file="pca_lograt.html", selfcontained = F))

# # plot so that it renders in github notebook
# htmltools::tags$iframe(
#   src=file.path("Embedded_figures/pca_lograt.html"),
#   width="100%",
#   height="600",
#   scrolling="no",
#   seamless="seamless",
#   frameBorder="0"
# )
 
```
The CLR-Euclidean PCA reveals there is some separation according to East vs West. The PCA only explains ~36% of the variance so keep going with different ordinations to see if we can get a better representation

Test embedding image in-line instead of as code chunk:
<iframe src="Embedded_figures/pca_lograt.html" height="600px" width="100%" style="border:none;"></iframe>




### PCoA
The more traditional approach to ordinations is to do a PCoA on a distance matrix such as Bray-Curtis, Jaccard, or Unifrac. While these are not considered compositional approaches, when combined with pre-treatment (transformations) they become more appropriate. One such transformation that I will use here is the Hellinger transformation.

The different distance matrices also tell you a few different things about the dataset so I will run through this to try to see if I can tease those out. 

Before calculating any distance matrix, do a transformation of the filtered count table. Hellinger transformation is the square root of the relative abundance, so calculate it based on the ps_ra object:
```{r}
ps_hellinger <- transform_sample_counts(ps_ra, function(x){sqrt(x)})

```


First, **Jaccard**, which builds the distance matrix based on presence/absence between samples. It does not take into account relative abundance of the taxa. Therefore this functions well for determining differences driven by rare taxa, which are weighed the same as abundant taxa.
```{r}
jac_dmat<-vegdist(otu_table(ps_hellinger),method="jaccard") # Jaccard dist metric
pcoa_jac<-ape::pcoa(jac_dmat) # perform PCoA

# Extract variances from pcoa, from jaccard calculated dist. metric
jac_variances <- data.frame(pcoa_jac$values$Relative_eig) %>% 
  select(PercVar = 'pcoa_jac.values.Relative_eig') %>% 
  rownames_to_column(var = "PCaxis") %>% 
  data.frame
head(jac_variances)

# Make a screeplot
ggplot(jac_variances, aes(x = as.numeric(PCaxis), y = PercVar)) + 
  geom_bar(stat = "identity", fill = "grey", color = "black") +
  theme_minimal() +
  theme(axis.title = element_text(color = "black", face = "bold", size = 10),
        axis.text.y = element_text(color = "black", face = "bold"),
        axis.text.x = element_blank()) +
  labs(x = "PC axis", y = "% Variance", title = "Jaccard PCoA Screeplot")
```
The first two axes (19.0 + 9.6 = 28.6) are OK. But I am going to experiment and plot the first 3 axes since the 2nd and 3rd explain a similar amount of variance, 19.6 and 8.4% respectively 

Plot in 3D with Plotly
```{r}
# Extract variances from the jaccard pcoa
pcoa_jac_df <- data.frame(pcoa_jac$vectors) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
pcoa_jac_df <- left_join(pcoa_jac_df, metadata, by = "SampleID")
head(pcoa_jac_df)

# Select eigenvalues from dataframe, round to 4 places and multiply by 100 for plotting. These will be the axes for the 3-D plot
eigenvalues<-round(jac_variances[,2], digits = 4)*100

# Plotly - 3-D
pcoa_jaccard <- plot_ly(pcoa_jac_df, type='scatter3d', mode='markers',
        x=~Axis.2,y=~Axis.3,z=~Axis.1,colors=~brewer.pal(11,'Paired'),
        color=~Station, symbols = c('circle','diamond'), symbol=~Bayside)%>%
  layout(font=list(size=12),
         title='PCoA Jaccard Distance',
         scene=list(xaxis=list(title=paste0('Co 2 ',eigenvalues[2],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    yaxis=list(title=paste0('Co 3 ',eigenvalues[3],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    zaxis=list(title=paste0('Co 1 ',eigenvalues[1],'%'),
                               showticklabels=FALSE,zerolinecolor='black')))
pcoa_jaccard

withr::with_dir('Figures', htmlwidgets::saveWidget(as_widget(pcoa_jaccard), file="pcoa_jaccard.html"))
```
The Jaccard-PCoA shows separation along axis 2 in East vs West differences.



Next, try a **Bray-Curtis** distance matrix with PCoA, which builds the distance matrix based on presence/absence between samples *and* relative abundance differences. This ordination will represent well the differences in samples that are driven by taxa with high relative abundances.
```{r}
bray_dmat<-vegdist(otu_table(ps_hellinger),method="bray") # Bray-Curtis dist metric
pcoa_bray<-ape::pcoa(bray_dmat) # perform PCoA

# Extract variances from pcoa, from jaccard calculated dist. metric
bray_variances <- data.frame(pcoa_bray$values$Relative_eig) %>% 
  select(PercVar = 'pcoa_bray.values.Relative_eig') %>% 
  rownames_to_column(var = "PCaxis") %>% 
  data.frame
head(bray_variances)

# Make a screeplot
ggplot(bray_variances, aes(x = as.numeric(PCaxis), y = PercVar)) + 
  geom_bar(stat = "identity", fill = "grey", color = "black") +
  theme_minimal() +
  theme(axis.title = element_text(color = "black", face = "bold", size = 10),
        axis.text.y = element_text(color = "black", face = "bold"),
        axis.text.x = element_blank()) +
  labs(x = "PC axis", y = "% Variance", title = "Bray-Curtis PCoA Screeplot")
```
The first two axes (27.7 + 14.3 = 42%) are pretty good again but I am still going to experiment in the plot with the 3rd axis since it is similar to the second (12.2% variance)




Plot in 3D with Plotly
```{r}
# Extract variances from the jaccard pcoa
pcoa_bray_df <- data.frame(pcoa_bray$vectors) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
pcoa_bray_df <- left_join(pcoa_bray_df, metadata, by = "SampleID")
head(pcoa_bray_df)

# Select eigenvalues from dataframe, round to 4 places and multiply by 100 for plotting. These will be the axes for the 3-D plot
eigenvalues<-round(bray_variances[,2], digits = 4)*100

# Plotly - 3-D
pcoa_bray <- plot_ly(pcoa_bray_df, type='scatter3d', mode='markers',
        x=~Axis.2,y=~Axis.3,z=~Axis.1,colors=~brewer.pal(11,'Paired'),
        color=~Station, symbols = c('circle','diamond'), symbol=~Bayside)%>%  
  layout(font=list(size=12),
         title='PCoA Bray-Curtis Distance',
         scene=list(xaxis=list(title=paste0('Co 2 ',eigenvalues[2],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    yaxis=list(title=paste0('Co 3 ',eigenvalues[3],'%'),
                               showticklabels=FALSE,zerolinecolor='black'),
                    zaxis=list(title=paste0('Co 1 ',eigenvalues[1],'%'),
                               showticklabels=FALSE,zerolinecolor='black')))
pcoa_bray

withr::with_dir('Figures', htmlwidgets::saveWidget(as_widget(pcoa_bray), file="pcoa_bray.html"))
```

These results are similar to Jaccard: the second axis seems driven by differences in East vs West. But there are clearly other things going on here with axies 1 and 3.
I think this is a good representation of the data: together the 3 axes explain 54.13% of the variance.




### NMDS
Lastly, try a non-metric dimensional scaling ordination. PCA/PCoA are metric and attempt to rotate axes to fit the distance matrix distribution. An NMDS represents the data in 2-axes, by constraining the distribution of the points. Similar to above, this can be combined with different pre-treatment of the data.

First try the compositional approach, an **NMDS on CLR-tranformed data using the Euclidean distances** (aka Aitchison distance)

```{r}
euc_dmat<-dist(clr_asv_table_ps, method = "euclidean") # Build the Aitchison distance matrix
euc_nmds <- metaMDS(euc_dmat, k=2, autotransform=FALSE) # Run the ordination
euc_nmds$stress #Check the stress. Less than 0.1 is good. Less than 0.05 is better. This will be different each time, since it is iteratively finding a unique solution each time (although the should look similar)

# Extract points from nmds and merge into data frame with metadata 
euc_nmds_df <- data.frame(euc_nmds$points) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
euc_nmds_df <- left_join(euc_nmds_df, metadata, by = "SampleID")
head(euc_nmds_df)



## Plotting euclidean distance NMDS
nmds_aitch <- ggplot(euc_nmds_df,aes(x = MDS1, y = MDS2, color = Station, shape = Bayside)) +
  geom_point(size = 4) +
  scale_color_brewer(palette="Paired") +
  theme_bw() +
  labs(x = "NMDS 1", y = "NMDS 2", title = paste0('Aitchison Distance NMDS, Stress = ', round(euc_nmds$stress,2))) +
  coord_fixed(ratio = 1)

nmds_aitch

ggsave("figures/nmds_aitch.eps",nmds_aitch, width = 7, height = 5, units = c("in"))
```
The above has a relatively high stress (>0.2) so should be interpreted with caution. But it does show some separation East vs West along NMDS 1.



Next try a **Jaccard NMDS**, which will represent differences in presence/absence among samples, emphasizing both abundant and rare taxa the same

```{r}
jac_nmds <- metaMDS(jac_dmat, k=2, autotransform=FALSE) # Run the ordination. Distance matrix was already calculated above
jac_nmds$stress #Check the stress. Less than 0.1 is good. Less than 0.5 is better. This will be different each time, since it is iteratively finding a unique solution each time (although the should look similar)

# Extract points from nmds and merge into data frame with metadata 
jac_nmds_df <- data.frame(jac_nmds$points) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
jac_nmds_df <- left_join(jac_nmds_df, metadata, by = "SampleID")
head(jac_nmds_df)



## Plotting euclidean distance NMDS
nmds_jaccard <- ggplot(jac_nmds_df,aes(x = MDS1, y = MDS2, color = Station, shape = Bayside)) +
  geom_point(size = 4) +
  scale_color_brewer(palette="Paired") +
  theme_bw() +
  labs(x = "NMDS 1", y = "NMDS 2", title = paste0('Jaccard Distance NMDS, Stress = ', round(jac_nmds$stress,2))) +
  coord_fixed(ratio = 1)

nmds_jaccard

ggsave("figures/nmds_jaccard.eps",nmds_jaccard, width = 7, height = 5, units = c("in"))
```
This is still a relatively high stress (>0.1) so should be interpreted with caution. Similar to Aitchison-distance nMDS but there is a little more separation of East vs West on NMDS 2 axis.


Next try a **Bray-Curis NMDS**, which will represent differences in presence/absence among samples *and* relative abundance, thus emphasizing impacts of highly abundant taxa.

```{r}
bray_nmds <- metaMDS(bray_dmat, k=2, autotransform=FALSE) # Run the ordination. Distance matrix was already calculated above
bray_nmds$stress #Check the stress. Less than 0.1 is good. Less than 0.5 is better. This will be different each time, since it is iteratively finding a unique solution each time (although the should look similar)

# Extract points from nmds and merge into data frame with metadata 
bray_nmds_df <- data.frame(bray_nmds$points) %>% 
  rownames_to_column(var = "SampleID")

# Merge metadata into the pcoa data table
bray_nmds_df <- left_join(bray_nmds_df, metadata, by = "SampleID")
head(bray_nmds_df)



## Plotting euclidean distance NMDS
nmds_bray <- ggplot(bray_nmds_df,aes(x = MDS1, y = MDS2, color = Station, shape = Bayside)) +
  geom_point(size = 4) +
  scale_color_brewer(palette="Paired") +
  theme_bw() +
  labs(x = "NMDS 1", y = "NMDS 2", title = paste0('Bray-Curtis Distance NMDS, Stress = ', round(bray_nmds$stress,2))) +
  coord_fixed(ratio = 1)

nmds_bray

ggsave("figures/nmds_bray.eps",nmds_bray, width = 7, height = 5, units = c("in"))
```
Very similar to Jaccard results. High-ish stress (0.15) 


--> CONTINUE HERE

#### Summary
XXX


